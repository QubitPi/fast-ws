"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[5791],{3358:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"restassured-json","metadata":{"permalink":"/jersey-webservice-template/blog/restassured-json","editUrl":"https://github.com/QubitPi/jersey-webservice-template/tree/master/docs/blog/2023-04-21-restassured-json.md","source":"@site/blog/2023-04-21-restassured-json.md","title":"(RestAssured) Match JSON Ignoring Order","description":"[//]: # (Copyright Jiaqi Liu)","date":"2023-04-21T00:00:00.000Z","formattedDate":"April 21, 2023","tags":[{"label":"Java","permalink":"/jersey-webservice-template/blog/tags/java"},{"label":"Testing","permalink":"/jersey-webservice-template/blog/tags/testing"}],"readingTime":0.73,"hasTruncateMarker":true,"authors":[{"name":"Jack","title":"Maintainer of Jersey Webservice Template","url":"https://github.com/QubitPi","imageURL":"https://avatars.githubusercontent.com/u/16126939?v=4","key":"jiaqi"}],"frontMatter":{"slug":"restassured-json","title":"(RestAssured) Match JSON Ignoring Order","authors":"jiaqi","tags":["Java","Testing"]},"unlisted":false,"nextItem":{"title":"Provider v.s. @Provider","permalink":"/jersey-webservice-template/blog/provider"}},"content":"[//]: # (Copyright Jiaqi Liu)\\n\\n[//]: # (Licensed under the Apache License, Version 2.0 &#40;the \\"License\\"&#41;;)\\n[//]: # (you may not use this file except in compliance with the License.)\\n[//]: # (You may obtain a copy of the License at)\\n\\n[//]: # (    http://www.apache.org/licenses/LICENSE-2.0)\\n\\n[//]: # (Unless required by applicable law or agreed to in writing, software)\\n[//]: # (distributed under the License is distributed on an \\"AS IS\\" BASIS,)\\n[//]: # (WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.)\\n[//]: # (See the License for the specific language governing permissions and)\\n[//]: # (limitations under the License.)\\n\\n\x3c!--truncate--\x3e\\n\\nUse RestAssured\'s JsonPath to parse the JSON file into a Map and then compare it with Hamcrest Matchers. This way the\\norder didn\'t matter.\\n\\n```java\\nimport static org.hamcrest.Matchers.equalTo;\\nimport io.restassured.path.json.JsonPath;\\n\\n...\\n\\nJsonPath expectedJson = new JsonPath(new File(\\"/path/to/expected.json\\"));\\n\\ngiven()\\n    ...\\n    .then()\\n    .body(\\"\\", equalTo(expectedJson.getMap(\\"\\")));\\n```"},{"id":"provider","metadata":{"permalink":"/jersey-webservice-template/blog/provider","editUrl":"https://github.com/QubitPi/jersey-webservice-template/tree/master/docs/blog/2022-09-24-provider.md","source":"@site/blog/2022-09-24-provider.md","title":"Provider v.s. @Provider","description":"[//]: # (Copyright Jiaqi Liu)","date":"2022-09-24T00:00:00.000Z","formattedDate":"September 24, 2022","tags":[{"label":"Java","permalink":"/jersey-webservice-template/blog/tags/java"}],"readingTime":1.025,"hasTruncateMarker":true,"authors":[{"name":"Jack","title":"Maintainer of Jersey Webservice Template","url":"https://github.com/QubitPi","imageURL":"https://avatars.githubusercontent.com/u/16126939?v=4","key":"jiaqi"}],"frontMatter":{"slug":"provider","title":"Provider v.s. @Provider","authors":"jiaqi","tags":["Java"]},"unlisted":false,"prevItem":{"title":"(RestAssured) Match JSON Ignoring Order","permalink":"/jersey-webservice-template/blog/restassured-json"},"nextItem":{"title":"Bearer Authentication","permalink":"/jersey-webservice-template/blog/bearer-authentication"}},"content":"[//]: # (Copyright Jiaqi Liu)\\n\\n[//]: # (Licensed under the Apache License, Version 2.0 &#40;the \\"License\\"&#41;;)\\n[//]: # (you may not use this file except in compliance with the License.)\\n[//]: # (You may obtain a copy of the License at)\\n\\n[//]: # (    http://www.apache.org/licenses/LICENSE-2.0)\\n\\n[//]: # (Unless required by applicable law or agreed to in writing, software)\\n[//]: # (distributed under the License is distributed on an \\"AS IS\\" BASIS,)\\n[//]: # (WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.)\\n[//]: # (See the License for the specific language governing permissions and)\\n[//]: # (limitations under the License.)\\n\\n\x3c!--truncate--\x3e\\n\\nA **Provider** is an interface defined in [JSR 330][JSR 330 Provider]. It is part of the _general_ dependency\\ninjection concept in Java.\\n\\nWhether we are on Java SR or EE, Provider will always be loadable from classpath. For example, the [HK2] is an\\nimplementation of JSR-330 in a JavaSE environment and it conforms to the JSR 330 standard by loading the\\n[Provider][JSR 330 Provider] in its implementations.\\n\\n**@Provider**, on the other hand, is a\\n[_Java EE/Jakarta EE concept_](https://github.com/jakartaee/rest/blob/master/jaxrs-api/src/main/java/jakarta/ws/rs/ext/Provider.java).\\nIf we are developing Java EE applications, we can use both (`Provider` & `@Provider`) at the same time.\\n\\n[JSR 330 Provider]: https://qubitpi.github.io/javax-inject/api/javax/inject/Provider.html\\n[HK2]: https://qubitpi.github.io/glassfish-hk2/"},{"id":"bearer-authentication","metadata":{"permalink":"/jersey-webservice-template/blog/bearer-authentication","editUrl":"https://github.com/QubitPi/jersey-webservice-template/tree/master/docs/blog/2022-09-12-bearer-authentication.md","source":"@site/blog/2022-09-12-bearer-authentication.md","title":"Bearer Authentication","description":"[//]: # (Copyright Jiaqi Liu)","date":"2022-09-12T00:00:00.000Z","formattedDate":"September 12, 2022","tags":[{"label":"Security","permalink":"/jersey-webservice-template/blog/tags/security"}],"readingTime":1.15,"hasTruncateMarker":true,"authors":[{"name":"Jack","title":"Maintainer of Jersey Webservice Template","url":"https://github.com/QubitPi","imageURL":"https://avatars.githubusercontent.com/u/16126939?v=4","key":"jiaqi"}],"frontMatter":{"slug":"bearer-authentication","title":"Bearer Authentication","authors":"jiaqi","tags":["Security"]},"unlisted":false,"prevItem":{"title":"Provider v.s. @Provider","permalink":"/jersey-webservice-template/blog/provider"},"nextItem":{"title":"Tired of Null Pointer Exceptions? Consider Using Java SE 8\'s \\"Optional\\"","permalink":"/jersey-webservice-template/blog/java-optional"}},"content":"[//]: # (Copyright Jiaqi Liu)\\n\\n[//]: # (Licensed under the Apache License, Version 2.0 &#40;the \\"License\\"&#41;;)\\n[//]: # (you may not use this file except in compliance with the License.)\\n[//]: # (You may obtain a copy of the License at)\\n\\n[//]: # (    http://www.apache.org/licenses/LICENSE-2.0)\\n\\n[//]: # (Unless required by applicable law or agreed to in writing, software)\\n[//]: # (distributed under the License is distributed on an \\"AS IS\\" BASIS,)\\n[//]: # (WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.)\\n[//]: # (See the License for the specific language governing permissions and)\\n[//]: # (limitations under the License.)\\n\\n\x3c!--truncate--\x3e\\n\\n**Bearer authentication** (also called **token authentication**) is an\\n[HTTP authentication scheme][HTTP authentication scheme] that involves security tokens called bearer tokens. The name\\n\\"Bearer authentication\\" can be understood as \\"give access to the bearer of this token.\\" The bearer token is a cryptic\\nstring, usually generated by the server in response to a login request. The client must send this token in the\\n`Authorization` header when making requests to protected resources:\\n\\n```bash\\nAuthorization: Bearer <token>\\n```\\n\\nThe Bearer authentication scheme was originally created as part of [OAuth 2.0][OAuth 2.0] in [RFC 6750][RFC 6750], but\\nis sometimes also used on its own. Similarly to [Basic authentication][Basic authentication], Bearer authentication\\nshould only be used over HTTPS (SSL).\\n\\n[RFC 6750]: https://tools.ietf.org/html/rfc6750\\n[OAuth 2.0]: https://swagger.io/docs/specification/authentication/oauth2/\\n[HTTP authentication scheme]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication\\n[Basic authentication]: https://swagger.io/docs/specification/authentication/basic-authentication/"},{"id":"java-optional","metadata":{"permalink":"/jersey-webservice-template/blog/java-optional","editUrl":"https://github.com/QubitPi/jersey-webservice-template/tree/master/docs/blog/2022-09-07-java-optional/index.md","source":"@site/blog/2022-09-07-java-optional/index.md","title":"Tired of Null Pointer Exceptions? Consider Using Java SE 8\'s \\"Optional\\"","description":"[//]: # (Copyright Jiaqi Liu)","date":"2022-09-07T00:00:00.000Z","formattedDate":"September 7, 2022","tags":[{"label":"Java","permalink":"/jersey-webservice-template/blog/tags/java"}],"readingTime":11.475,"hasTruncateMarker":true,"authors":[{"name":"Jack","title":"Maintainer of Jersey Webservice Template","url":"https://github.com/QubitPi","imageURL":"https://avatars.githubusercontent.com/u/16126939?v=4","key":"jiaqi"}],"frontMatter":{"slug":"java-optional","title":"Tired of Null Pointer Exceptions? Consider Using Java SE 8\'s \\"Optional\\"","authors":"jiaqi","tags":["Java"]},"unlisted":false,"prevItem":{"title":"Bearer Authentication","permalink":"/jersey-webservice-template/blog/bearer-authentication"},"nextItem":{"title":"Happy Path","permalink":"/jersey-webservice-template/blog/happy-path"}},"content":"[//]: # (Copyright Jiaqi Liu)\\n\\n[//]: # (Licensed under the Apache License, Version 2.0 &#40;the \\"License\\"&#41;;)\\n[//]: # (you may not use this file except in compliance with the License.)\\n[//]: # (You may obtain a copy of the License at)\\n\\n[//]: # (    http://www.apache.org/licenses/LICENSE-2.0)\\n\\n[//]: # (Unless required by applicable law or agreed to in writing, software)\\n[//]: # (distributed under the License is distributed on an \\"AS IS\\" BASIS,)\\n[//]: # (WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.)\\n[//]: # (See the License for the specific language governing permissions and)\\n[//]: # (limitations under the License.)\\n\\nMake your code more readable and protect it against null pointer exceptions.\\n\\n\x3c!--truncate--\x3e\\n\\nA wise man once said you are not a real Java programmer until you\'ve dealt with a null pointer exception. Joking aside,\\nthe null reference is the source of many problems because it is often used to denote the absence of a value. Java SE 8\\nintroduces a new class called **java.util.Optional** that can alleviate some of these problems.\\n\\nDangers of Null\\n---------------\\n\\nLet\'s start with an example to see the dangers of null by considering a nested object structure for a `Computer`, as\\nillustrated in Figure below\\n\\n![Error loading java-optional-computer.png](java-optional-computer.png)\\n\\nWhat\'s possibly problematic with the following code?\\n\\n```java\\nString version = computer.getSoundcard().getUSB().getVersion();\\n```\\n\\nThis code looks pretty reasonable. However, many computers (for example, the Raspberry Pi) don\'t actually ship with a\\nsound card. So what is the result of `getSoundcard()`?\\n\\nA common (bad) practice is to return the null reference to indicate the absence of a sound card. Unfortunately, this\\nmeans the call to `getUSB()` will try to return the USB port of a null reference, which will result in a\\n`NullPointerException` at runtime and stop your program from running further. Imagine if your program was running on a\\ncustomer\'s machine; what would your customer say if the program suddenly failed?\\n\\nTo give some historical context, Tony Hoare - one of the giants of computer science - wrote, \\"I call it my\\nbillion-dollar mistake. It was the invention of the null reference in 1965. I couldn\'t resist the temptation to put in\\na null reference, simply because it was so easy to implement.\\"\\n\\nWhat can you do to prevent unintended null pointer exceptions? You can be defensive and add checks to prevent null\\ndereferences, as shown below:\\n\\n```java\\nString version = \\"UNKNOWN\\";\\nif (computer != null) {\\n    Soundcard soundcard = computer.getSoundcard();\\n    if(soundcard != null){\\n        USB usb = soundcard.getUSB();\\n        if(usb != null){\\n            version = usb.getVersion();\\n        }\\n    }\\n}\\n```\\n\\nHowever, you can see that the code quickly becomes very ugly due to the nested checks. Unfortunately, we need a lot of\\nboilerplate code to make sure we don\'t get a NullPointerException. In addition, it\'s just annoying that these checks get\\nin the way of the business logic. In fact, they are decreasing the overall readability of our program.\\n\\nFurthermore, it is an error-prone process; what if you forget to check that one property could be null? I will argue in\\nthis post that using null to represent the absence of a value is a wrong approach. What we need is a better way to\\nmodel the absence and presence of a value.\\n\\nTo give some context, let\'s briefly look at what other programming languages have to offer.\\n\\nWhat Alternatives to Null Are There\\n-----------------------------------\\n\\nLanguages such as Groovy have a _safe navigation operator_ represented by \\"?.\\" to safely navigate through potential\\nnull references. (Note that it is soon to be included in C#, too, and it was proposed for Java SE 7 but didn\'t make it\\ninto that release.) It works as follows:\\n\\n```groovy\\nString version = computer?.getSoundcard()?.getUSB()?.getVersion()\\n```\\n\\nIn this case, the variable \\"version\\" will be assigned to null if `computer` is null, or `getSoundcard()` returns null,\\nor `getUSB()` returns null. You don\'t need to write complex nested conditions to check for null.\\n\\nIn addition, Groovy also includes the _Elvis operator_ \\"?:\\" (if you look at it sideways, you\'ll recognize Elvis\' famous\\nhair), which can be used for simple cases when a default value is needed. In the following, if the expression that uses\\nthe safe navigation operator returns null, the default value \\"UNKNOWN\\" is returned; otherwise, the available version\\ntag is returned.\\n\\n```groovy\\nString version = computer?.getSoundcard()?.getUSB()?.getVersion() ?: \\"UNKNOWN\\"\\n```\\n\\nOther functional languages, such as Haskell and Scala, take a different view. Haskell includes a **Maybe** type, which\\nessentially encapsulates an optional value. A value of type Maybe can contain either a value of a given type or\\nnothing. There is no concept of a null reference. Scala has a similar construct called **Option\\\\[T\\\\]** to encapsulate\\nthe presence or absence of a value of type `T`. You then have to explicitly check whether a value is present or not\\nusing operations available on the `Option` type, which enforces the idea of \\"null checking.\\" **You can no longer\\n\\"forget to do it\\" because it is enforced by the type system**.\\n\\nJava 8 _Optional_ in a Nutshell\\n-------------------------------\\n\\nJava SE 8 introduces a new class called `java.util.Optional<T>` that is inspired from the ideas of Haskell and Scala.\\nIt is a class that encapsulates an optional value, as illustrated in figure below. You can view `Optional` as a\\nsingle-value container that either contains a value or doesn\'t (it is then said to be \\"empty\\"):\\n\\n![Error loading java-optional-eg.png](java-optional-eg.png)\\n\\nWe can update our model to make use of Optional, as shown in Listing 2:\\n\\n```java\\npublic class Computer {\\n    private Optional<Soundcard> soundcard;\\n    public Optional<Soundcard> getSoundcard() { ... }\\n    ...\\n}\\n\\npublic class Soundcard {\\n    private Optional<USB> usb;\\n    public Optional<USB> getUSB() { ... }\\n}\\n\\npublic class USB {\\n    public String getVersion(){ ... }\\n}\\n```\\n\\nThe code above immediately shows that a computer might or might not have a sound card (the sound card is optional). In\\naddition, a sound card can optionally have a USB port. This is an improvement, because this new model can now reflect\\nclearly whether a given value is allowed to be missing.\\n\\nBut what can you actually do with an `Optional<Soundcard>` object? After all, you want to get to the USB port\'s version\\nnumber. In a nutshell, the `Optional` class includes methods to explicitly deal with the cases where a value is present\\nor absent. However, the advantage compared to null references is that the `Optional` class forces us to think about the\\ncase when the value is not present. As a consequence, we can prevent unintended null pointer exceptions.\\n\\nIt is important to note that the intention of the `Optional` class is not to replace every single null reference.\\nInstead, its purpose is to help design more-comprehensible APIs so that by just reading the signature of a method, you\\ncan tell whether you can expect an optional value. This forces you to actively unwrap an `Optional` to deal with the\\nabsence of a value.\\n\\nUsing Optional\\n--------------\\n\\nThe Groovy code above can be written with Optional in Java as\\n\\n```java\\nString name = computer.flatMap(Computer::getSoundcard)\\n        .flatMap(Soundcard::getUSB)\\n        .map(USB::getVersion)\\n        .orElse(\\"UNKNOWN\\");\\n```\\n\\n### Creating Optional Objects\\n\\nFirst, how do you create Optional objects? There are several ways:\\n\\nHere is an empty Optional:\\n\\n```java\\nOptional<Soundcard> sc = Optional.empty();\\n```\\n\\nAnd here is an `Optional` with a non-null value:\\n\\n```java\\nOptional<Soundcard> sc = Optional.of(new Soundcard());\\n```\\n\\nIn the case above, if soundcard were null, a NullPointerException would be immediately thrown (rather than getting a\\nlatent error once you try to access properties of the soundcard)\\n\\nBy using **ofNullable**, however, you can create an Optional object that may hold a null value:\\n\\n```java\\nOptional<Soundcard> sc = Optional.ofNullable(soundcard);\\n```\\n\\nIf soundcard were null, the resulting `Optional` object would be empty.\\n\\n### Do Something If a Value Is Present\\n\\nNow that you have an Optional object, you can access the methods available to explicitly deal with the presence or\\nabsence of values. Instead of having to remember to do a null check, as follows:\\n\\n```java\\nSoundCard soundcard = ...;\\nif(soundcard != null){\\n    System.out.println(soundcard);\\n}\\n```\\n\\nYou can use the **ifPresent()** method, as follows:\\n\\n```java\\nOptional<Soundcard> soundcard = ...;\\nsoundcard.ifPresent(System.out::println);\\n```\\n\\nYou no longer need to do an explicit null check; it is enforced by the type system. If the Optional object were empty,\\nnothing would be printed.\\n\\nYou can also use the **isPresent()** method to find out whether a value is present in an Optional object. In addition,\\nthere\'s a **get()** method that returns the value contained in the Optional object, if it is present. _Otherwise,\\nit throws a NoSuchElementException_. The two methods can be combined, as follows, to prevent exceptions:\\n\\n```java\\nif(soundcard.isPresent()){\\n    System.out.println(soundcard.get());\\n}\\n```\\n\\nHowever, this is not the recommended use of Optional because it\'s not much of an improvement over nested null checks,\\nand there are more idiomatic alternatives, which we explore below.\\n\\n### Default Values and Actions\\n\\nA typical pattern is to return a default value if you determine that the result of an operation is null. In general,\\nyou can use the ternary operator, as follows, to achieve this:\\n\\n```java\\nSoundcard soundcard = maybeSoundcard != null ? maybeSoundcard : new Soundcard(\\"basic_sound_card\\");\\n```\\n\\nUsing an Optional object, you can rewrite this code by using the **orElse()** method, which provides a default value if\\nOptional is empty:\\n\\n```java\\nSoundcard soundcard = maybeSoundcard.orElse(new Soundcard(\\"defaut\\"));\\n```\\n\\nSimilarly, you can use the **orElseThrow()** method, which instead of providing a default value if Optional is empty,\\nthrows an exception:\\n\\n```java\\nSoundcard soundcard = maybeSoundCard.orElseThrow(IllegalStateException::new);\\n```\\n\\n### Rejecting Certain Values Using the filter Method\\n\\nOften you need to call a method on an object and check some property. For example, you might need to check whether the\\nUSB port is a particular version. To do this in a safe way, you first need to check whether the reference pointing to a\\nUSB object is null and then call the `getVersion()` method, as follows:\\n\\n```java\\nUSB usb = ...;\\nif(usb != null && \\"3.0\\".equals(usb.getVersion())){\\n    System.out.println(\\"ok\\");\\n}\\n```\\n\\nThis pattern can be rewritten using the **filter** method on an Optional object, as follows:\\n\\n```java\\nOptional<USB> maybeUSB = ...;\\nmaybeUSB.filter(usb -> \\"3.0\\".equals(usb.getVersion()).ifPresent(() -> System.out.println(\\"ok\\"));\\n```\\n\\nThe `filter` method takes a predicate as an argument. If a value is present in the `Optional` object and it matches the\\npredicate, the filter method returns that value; otherwise, it returns an empty `Optional` object.\\n\\n### Extracting and Transforming Values Using the map Method\\n\\nAnother common pattern is to extract information from an object. For example, from a `Soundcard` object, you might want\\nto extract the USB object and then further check whether it is of the correct version. You would typically write the\\nfollowing code:\\n\\n```java\\nif(soundcard != null){\\n    USB usb = soundcard.getUSB();\\n    if(usb != null && \\"3.0\\".equals(usb.getVersion()){\\n        System.out.println(\\"ok\\");\\n    }\\n}\\n```\\n\\nWe can rewrite this pattern of \\"checking for null and extracting\\" (here, the `Soundcard` object) using the map method.\\n\\n```java\\nOptional<USB> usb = maybeSoundcard.map(Soundcard::getUSB);\\n```\\n\\nThere\'s a direct parallel to the `map` method used with streams. There, you pass a function to the `map` method, which\\napplies this function to each element of a stream. However, nothing happens if the stream is empty. The `map` method of\\nthe `Optional` class does exactly the same: the value contained inside `Optional` is \\"transformed\\" by the function\\npassed as an argument (here, a method reference to extract the USB port), while nothing happens if `Optional` is empty.\\n\\nFinally, we can combine the `map` method with the `filter` method to reject a USB port whose version is different than\\n3.0:\\n\\n```java\\nmaybeSoundcard.map(Soundcard::getUSB)\\n        .filter(usb -> \\"3.0\\".equals(usb.getVersion())\\n        .ifPresent(() -> System.out.println(\\"ok\\"));\\n```\\n\\n### Cascading Optional Objects Using the flatMap Method\\n\\nWe\'ve seen a few patterns that can be refactored to use Optional. So how can we write the following code in a safe way?\\n\\n```java\\nString version = computer.getSoundcard().getUSB().getVersion();\\n```\\n\\nNotice that all this code does is extract one object from another one, which is exactly what the map method is for.\\nEarlier in the article, we changed our model so a Computer has an `Optional<Soundcard>` and a Soundcard has an\\n`Optional<USB>`, so we should be able to write the following:\\n\\n```java\\nString version = computer.map(Computer::getSoundcard)\\n        .map(Soundcard::getUSB)\\n        .map(USB::getVersion)\\n        .orElse(\\"UNKNOWN\\");\\n```\\n\\nUnfortunately, this code doesn\'t compile. Why? The variable computer is of type `Optional<Computer>`, so it is\\nperfectly correct to call the `map` method. However, `getSoundcard()` returns an object of type `Optional<Soundcard>`.\\nThis means the result of the `map` operation is an object of type `Optional<Optional<Soundcard>>`. As a result, the\\ncall to `getUSB()` is invalid because the outermost Optional contains as its value another Optional, which of course\\ndoesn\'t support the `getUSB()` method\\n\\nSo how can we solve this problem? Again, we can look at a pattern you might have used previously with streams: the\\n**flatMap** method. With streams, the `flatMap` method takes a function as an argument, which returns another stream.\\nThis function is applied to each element of a stream, which would result in a stream of streams. However, `flatMap` has\\nthe effect of replacing each generated stream by the contents of that stream. In other words, all the separate streams\\nthat are generated by the function get amalgamated or \\"flattened\\" into one single stream. What we want here is\\nsomething similar, but we want to \\"flatten\\" a two-level Optional into one.\\n\\nWell, here\'s good news: `Optional` also supports a `flatMap` method. Its purpose is to apply the transformation\\nfunction on the value of an `Optional` and then flatten the resulting two-level Optional into a single one.\\n\\nSo, to make our code correct, we need to rewrite it as follows using `flatMap`:\\n\\n```java\\nString version = computer.flatMap(Computer::getSoundcard)\\n        .flatMap(Soundcard::getUSB)\\n        .map(USB::getVersion)\\n        .orElse(\\"UNKNOWN\\");\\n```\\n\\nThe first flatMap ensures that an `Optional<Soundcard>` is returned instead of an `Optional<Optional<Soundcard>>`, and\\nthe second flatMap achieves the same purpose to return an `Optional<USB>`. Note that the third call just needs to be a\\nmap() because getVersion() returns a String rather than an `Optional` object."},{"id":"happy-path","metadata":{"permalink":"/jersey-webservice-template/blog/happy-path","editUrl":"https://github.com/QubitPi/jersey-webservice-template/tree/master/docs/blog/2022-07-03-happy-path.md","source":"@site/blog/2022-07-03-happy-path.md","title":"Happy Path","description":"[//]: # (Copyright Jiaqi Liu)","date":"2022-07-03T00:00:00.000Z","formattedDate":"July 3, 2022","tags":[{"label":"Testing","permalink":"/jersey-webservice-template/blog/tags/testing"}],"readingTime":1.74,"hasTruncateMarker":true,"authors":[{"name":"Jack","title":"Maintainer of Jersey Webservice Template","url":"https://github.com/QubitPi","imageURL":"https://avatars.githubusercontent.com/u/16126939?v=4","key":"jiaqi"}],"frontMatter":{"slug":"happy-path","title":"Happy Path","authors":"jiaqi","tags":["Testing"]},"unlisted":false,"prevItem":{"title":"Tired of Null Pointer Exceptions? Consider Using Java SE 8\'s \\"Optional\\"","permalink":"/jersey-webservice-template/blog/java-optional"},"nextItem":{"title":"Defensive Copy","permalink":"/jersey-webservice-template/blog/defensive-copy"}},"content":"[//]: # (Copyright Jiaqi Liu)\\n\\n[//]: # (Licensed under the Apache License, Version 2.0 &#40;the \\"License\\"&#41;;)\\n[//]: # (you may not use this file except in compliance with the License.)\\n[//]: # (You may obtain a copy of the License at)\\n\\n[//]: # (    http://www.apache.org/licenses/LICENSE-2.0)\\n\\n[//]: # (Unless required by applicable law or agreed to in writing, software)\\n[//]: # (distributed under the License is distributed on an \\"AS IS\\" BASIS,)\\n[//]: # (WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.)\\n[//]: # (See the License for the specific language governing permissions and)\\n[//]: # (limitations under the License.)\\n\\nIn the context of software or information modeling, a happy path (sometimes called happy flow) is a default scenario\\nfeaturing no exceptional or error conditions. For example, the happy path for a function validating credit card numbers\\nwould be where none of the validation rules raise an error, thus letting execution continue successfully to the end,\\ngenerating a positive response.\\n\\n\x3c!--truncate--\x3e\\n\\nProcess steps for a happy path are also used in the context of a [use case](https://en.wikipedia.org/wiki/Use_case). In\\ncontrast to the happy path, process steps for alternate paths and exception paths may also be documented.\\n\\nHappy path test is a well-defined test case using known input, which executes without exception and produces an expected\\noutput. Happy path testing can show that a system meets its functional requirements but it doesn\'t guarantee a graceful\\nhandling of error conditions or aid in finding hidden bugs.\\n\\n> Happy day (or sunny day) scenario and golden path are synonyms for happy path.\\n\\nIn use case analysis, there is only one happy path, but there may be any number of additional alternate path scenarios\\nwhich are all valid optional outcomes. If valid alternatives exist, the happy path is then identified as the default or\\nmost likely positive alternative. The analysis may also show one or more exception paths. An exception path is taken as\\nthe result of a fault condition. Use cases and the resulting interactions are commonly modeled in graphical languages\\nsuch as the Unified Modeling Language (UML) or SysML"},{"id":"defensive-copy","metadata":{"permalink":"/jersey-webservice-template/blog/defensive-copy","editUrl":"https://github.com/QubitPi/jersey-webservice-template/tree/master/docs/blog/2022-01-05-java-dc.md","source":"@site/blog/2022-01-05-java-dc.md","title":"Defensive Copy","description":"[//]: # (Copyright Jiaqi Liu)","date":"2022-01-05T00:00:00.000Z","formattedDate":"January 5, 2022","tags":[{"label":"Java","permalink":"/jersey-webservice-template/blog/tags/java"}],"readingTime":4.21,"hasTruncateMarker":true,"authors":[{"name":"Jack","title":"Maintainer of Jersey Webservice Template","url":"https://github.com/QubitPi","imageURL":"https://avatars.githubusercontent.com/u/16126939?v=4","key":"jiaqi"}],"frontMatter":{"slug":"defensive-copy","title":"Defensive Copy","authors":"jiaqi","tags":["Java"]},"unlisted":false,"prevItem":{"title":"Happy Path","permalink":"/jersey-webservice-template/blog/happy-path"},"nextItem":{"title":"Understanding Weak References","permalink":"/jersey-webservice-template/blog/weak-references"}},"content":"[//]: # (Copyright Jiaqi Liu)\\n\\n[//]: # (Licensed under the Apache License, Version 2.0 &#40;the \\"License\\"&#41;;)\\n[//]: # (you may not use this file except in compliance with the License.)\\n[//]: # (You may obtain a copy of the License at)\\n\\n[//]: # (    http://www.apache.org/licenses/LICENSE-2.0)\\n\\n[//]: # (Unless required by applicable law or agreed to in writing, software)\\n[//]: # (distributed under the License is distributed on an \\"AS IS\\" BASIS,)\\n[//]: # (WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.)\\n[//]: # (See the License for the specific language governing permissions and)\\n[//]: # (limitations under the License.)\\n\\n\x3c!--truncate--\x3e\\n\\nA mutable object is simply an object which can change its state after construction. For example, `StringBuilder` and\\n`Date` are mutable objects, while `String` and `Integer` are immutable objects.\\n\\nA class may have a mutable object as a field. There are two possible cases for how the state of a mutable object field\\ncan change:\\n\\n1. its state can be changed only by the native class - the native class **creates the mutable object field**, and is the\\n   only class which is directly aware of its existence\\n2. its state can be changed both by the native class and by its callers - the native class simply **points to a mutable\\n   object** which was created elsewhere\\n\\nBoth cases are valid design choices, but you must be aware of which one is appropriate for each case.\\n\\n**If the _mutable_ object field\'s state should be changed only by the native class, then a defensive copy of the mutable\\nobject must be made any time it\'s passed into (constructors and set methods) or out of (\\"get\\" methods) the class**. If\\nthis is not done, then it\'s simple for the caller to break encapsulation, by changing the state of an object which is\\nsimultaneously visible to both the class and its caller.\\n\\n:::info\\n\\nIt is implied that the defensive copying is only required when the state is mutable\\n\\n:::\\n\\nFor example, `Planet` has a mutable object field `fDateOfDiscovery`, which is defensively copied in all constructors,\\nand in `getDateOfDiscovery`. `Planet` represents an immutable class, and has no \\"set\\" methods for its fields. Note that\\nif the defensive copy of `DateOfDiscovery` is not made, then `Planet` is no longer immutable!\\n\\n```java\\nimport java.util.Date;\\n\\n/**\\n* Planet is an immutable class, since there is no way to change\\n* its state after construction.\\n*/\\npublic final class Planet {\\n\\n    /**\\n     * Final primitive data is always immutable.\\n     */\\n    private final double mass;\\n\\n    /**\\n     * An immutable object field. (String objects never change state.)\\n     */\\n    private final String name;\\n\\n    /**\\n     * A mutable object field. In this case, the state of this mutable field\\n     * is to be changed only by this class. (In other cases, it makes perfect\\n     * sense to allow the state of a field to be changed outside the native\\n     * class; this is the case when a field acts as a \\"pointer\\" to an object\\n     * created elsewhere.)\\n     *\\n     * java.util.Date is used here only because its convenient for illustrating\\n     * a point about mutable objects. In new code, you should use\\n     * java.time classes, not java.util.Date.\\n     */\\n    private final Date dateOfDiscovery;\\n\\n    public Planet (double mass, String name, Date dateOfDiscovery) {\\n        this.mass = mass;\\n        this.name = name;\\n        //make a private copy of aDateOfDiscovery\\n        //this is the only way to keep the fDateOfDiscovery\\n        //field private, and shields this class from any changes that\\n        //the caller may make to the original aDateOfDiscovery object\\n        this.dateOfDiscovery = new Date(dateOfDiscovery.getTime());\\n    }\\n\\n    /**\\n    * Returns a primitive value.\\n    *\\n    * The caller can do whatever they want with the return value, without\\n    * affecting the internals of this class. Why? Because this is a primitive\\n    * value. The caller sees its \\"own\\" double that simply has the\\n    * same value as fMass.\\n    */\\n    public double getMass() {\\n        return mass;\\n    }\\n\\n    /**\\n    * Returns an immutable object.\\n    *\\n    * The caller gets a direct reference to the internal field. But this is not\\n    * dangerous, since String is immutable and cannot be changed.\\n    */\\n    public String getName() {\\n        return name;\\n    }\\n\\n//  /**\\n//  * Returns a mutable object - likely bad style.\\n//  *\\n//  * The caller gets a direct reference to the internal field. This is usually dangerous,\\n//  * since the Date object state can be changed both by this class and its caller.\\n//  * That is, this class is no longer in complete control of dateOfDiscovery.\\n//  */\\n//  public Date getDateOfDiscovery() {\\n//      return dateOfDiscovery;\\n//  }\\n\\n    /**\\n    * Returns a mutable object - good style.\\n    *\\n    * Returns a defensive copy of the field.\\n    * The caller of this method can do anything they want with the\\n    * returned Date object, without affecting the internals of this\\n    * class in any way. Why? Because they do not have a reference to\\n    * fDate. Rather, they are playing with a second Date that initially has the\\n    * same data as fDate.\\n    */\\n    public Date getDateOfDiscovery() {\\n        return new Date(dateOfDiscovery.getTime());\\n    }\\n}\\n```"},{"id":"weak-references","metadata":{"permalink":"/jersey-webservice-template/blog/weak-references","editUrl":"https://github.com/QubitPi/jersey-webservice-template/tree/master/docs/blog/2021-12-30-java-weak-reference.md","source":"@site/blog/2021-12-30-java-weak-reference.md","title":"Understanding Weak References","description":"[//]: # (Copyright Jiaqi Liu)","date":"2021-12-30T00:00:00.000Z","formattedDate":"December 30, 2021","tags":[{"label":"Java","permalink":"/jersey-webservice-template/blog/tags/java"}],"readingTime":8.525,"hasTruncateMarker":true,"authors":[{"name":"Jack","title":"Maintainer of Jersey Webservice Template","url":"https://github.com/QubitPi","imageURL":"https://avatars.githubusercontent.com/u/16126939?v=4","key":"jiaqi"}],"frontMatter":{"slug":"weak-references","title":"Understanding Weak References","authors":"jiaqi","tags":["Java"]},"unlisted":false,"prevItem":{"title":"Defensive Copy","permalink":"/jersey-webservice-template/blog/defensive-copy"},"nextItem":{"title":"Java 8 Stream","permalink":"/jersey-webservice-template/blog/java-stream"}},"content":"[//]: # (Copyright Jiaqi Liu)\\n\\n[//]: # (Licensed under the Apache License, Version 2.0 &#40;the \\"License\\"&#41;;)\\n[//]: # (you may not use this file except in compliance with the License.)\\n[//]: # (You may obtain a copy of the License at)\\n\\n[//]: # (    http://www.apache.org/licenses/LICENSE-2.0)\\n\\n[//]: # (Unless required by applicable law or agreed to in writing, software)\\n[//]: # (distributed under the License is distributed on an \\"AS IS\\" BASIS,)\\n[//]: # (WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.)\\n[//]: # (See the License for the specific language governing permissions and)\\n[//]: # (limitations under the License.)\\n\\n\x3c!--truncate--\x3e\\n\\nStrong References\\n-----------------\\n\\nA **strong reference** is an ordinary Java reference, the kind you use every day. For example, the code:\\n\\n```java\\nStringBuffer buffer = new StringBuffer();\\n```\\n\\ncreates a new `StringBuffer` and stores a strong reference to it in the variable `buffer`. Yes, yes, this is kiddie\\nstuff, but bear with me. _The important part about strong references -- the part that makes them \\"strong\\" -- is how they\\ninteract with the garbage collector_. Specifically, if an object is reachable via a chain of strong references (strongly\\nreachable), it is not eligible for garbage collection. As you don\'t want the garbage collector destroying objects you\'re\\nworking on, this is normally exactly what you want.\\n\\nWhen Strong References are Too Strong\\n-------------------------------------\\n\\nIt\'s not uncommon for an application to use classes that it can\'t reasonably extend. The class might simply be marked\\n`final`, or it could be something more complicated, such as an interface returned by a factory method backed by an\\nunknown (and possibly even unknowable) number of concrete implementations. Suppose you have to use a class `Widget` and,\\nfor whatever reason, it isn\'t possible or practical to extend `Widget` to add new functionality.\\n\\nWhat happens when you need to keep track of extra information about the object? In this case, suppose we find ourselves\\nneeding to keep track of each Widget\'s serial number, but the Widget class doesn\'t actually have a serial number\\nproperty -- and because Widget isn\'t extensible, we can\'t add one. No problem at all, that\'s what `HashMaps` are for:\\n\\n```java\\nserialNumberMap.put(widget, widgetSerialNumber);\\n```\\n\\nThis might look okay on the surface, but the strong reference to widget will almost certainly cause problems. We have to\\nknow (with 100% certainty) when a particular Widget\'s serial number is no longer needed, so we can remove its entry from\\nthe map. Otherwise we\'re going to have a memory leak (if we don\'t remove Widgets when we should) or we\'re going to\\ninexplicably find ourselves missing serial numbers (if we remove Widgets that we\'re still using). If these problems\\nsound familiar, they should: they are exactly the problems that users of non-garbage-collected languages face when\\ntrying to manage memory, and we\'re not supposed to have to worry about this in a more civilized language like Java.\\n\\nAnother common problem with strong references is caching, particular with very large structures like images. Suppose you\\nhave an application which has to work with user-supplied images, like the web site design tool I work on. Naturally you\\nwant to cache these images, because loading them from disk is very expensive and you want to avoid the possibility of\\nhaving two copies of the (potentially gigantic) image in memory at once. Because an image cache is supposed to prevent\\nus from reloading images when we don\'t absolutely need to, you will quickly realize that the cache should always contain\\na reference to any image which is already in memory. With ordinary strong references, though, that reference itself will\\nforce the image to remain in memory, which requires you (just as above) to somehow determine when the image is no longer\\nneeded in memory and remove it from the cache, so that it becomes eligible for garbage collection. Once again you are\\nforced to duplicate the behavior of the garbage collector and manually determine whether or not an object should be in\\nmemory.\\n\\nWeak References\\n---------------\\n\\nA **weak reference**, simply put, is a reference that isn\'t strong enough to force an object to remain in memory. Weak\\nreferences allow you to leverage the garbage collector\'s ability to determine reachability for you, so you don\'t have to\\ndo it yourself. You create a weak reference like this:\\n\\n```java\\nWeakReference weakWidget = new WeakReference(widget);\\n```\\n\\nand then elsewhere in the code you can use `weakWidget.get()` to get the actual Widget object. Of course the weak\\nreference isn\'t strong enough to prevent garbage collection, so you may find (if there are no strong references to the\\nwidget) that `weakWidget.get()` suddenly starts returning `null`.\\n\\nTo solve the \\"widget serial number\\" problem above, the easiest thing to do is use the built-in `WeakHashMap` class.\\n`WeakHashMap` works exactly like `HashMap`, except that the keys (not the values!) are referred to using weak\\nreferences. If a `WeakHashMap` key becomes garbage, its entry is removed automatically. This avoids the pitfalls\\ndescribed earlier and requires no changes other than the switch from `HashMap` to a `WeakHashMap`. If you\'re following\\nthe standard convention of referring to your maps via the Map interface, no other code needs to even be aware of the\\nchange.\\n\\nReference Queues\\n----------------\\n\\nOnce a `WeakReference` starts returning `null`, the object it pointed to has become garbage and the `WeakReference`\\nobject is pretty much useless. This generally means that some sort of cleanup is required; `WeakHashMap`, for example,\\nhas to remove such defunct entries to avoid holding onto an ever-increasing number of dead `WeakReferences`.\\n\\nThe `ReferenceQueue` class makes it easy to keep track of dead references. If you pass a `ReferenceQueue` into a weak\\nreference\'s constructor, the reference object will be automatically inserted into the reference queue when the object to\\nwhich it pointed becomes garbage. You can then, at some regular interval, process the `ReferenceQueue` and perform\\nwhatever cleanup is needed for dead references.\\n\\nDifferent Degrees of Weakness\\n-----------------------------\\n\\nUp to this point I\'ve just been referring to \\"weak references\\", but there are actually **4 degrees of reference\\nstrength** (in order from strongest to weakest):\\n\\n1. strong\\n2. soft\\n3. weak\\n4. phantom\\n\\nWe\'ve already discussed strong and weak references, so let\'s take a look at the other two.\\n\\nSoft References\\n---------------\\n\\nA **soft reference** is exactly like a weak reference, except that it is less eager to throw away the object to which it\\nrefers. An object which is only weakly reachable will be discarded at the next garbage collection cycle, but an object\\nwhich is softly reachable will generally stick around for a while.\\n\\nSoft references aren\'t required to behave any differently than weak references, but in practice softly reachable objects\\nare generally retained as long as memory is in plentiful supply. **This makes them an excellent foundation for a\\ncache**, such as the image cache described above, since you can let the garbage collector worry about both how reachable\\nthe objects are and how badly it needs the memory they are consuming.\\n\\nPhantom References\\n------------------\\n\\nA **phantom reference** is quite different than either soft reference or weak reference. Its grip on its object is so\\ntenuous that you can\'t even retrieve the object - its `get()` method always returns `null`. **The only use for such a\\nreference is keeping track of when it gets enqueued into a `ReferenceQueue`, as at that point you know the object to\\nwhich it pointed is dead**. How is that different from weak reference, though?\\n\\nThe difference is in exactly when the enqueuing happens. `WeakReferences` are enqueued as soon as the object to which\\nthey point becomes weakly reachable. This is before finalization or garbage collection has actually happened; in theory\\nthe object could even be \\"resurrected\\" by an unorthodox `finalize()` method, but the `WeakReference` would remain dead.\\n`PhantomReferences` are enqueued only when the object is physically removed from memory, and the `get()` method always\\nreturns `null` specifically to prevent you from being able to \\"resurrect\\" an almost-dead object.\\n\\nWhat good are `PhantomReferences`? I\'m only aware of two serious cases for them: first, they allow you to determine\\nexactly when an object was removed from memory. They are in fact the only way to determine that. This isn\'t generally\\nthat useful, but might come in handy in certain very specific circumstances like manipulating large images: if you know\\nfor sure that an image should be garbage collected, you can wait until it actually is before attempting to load the next\\nimage, and therefore make the dreaded `OutOfMemoryError` less likely.\\n\\nSecond, phantom references avoid a fundamental problem with finalization: `finalize()` methods can \\"resurrect\\" objects\\nby creating new strong references to them. So what, you say? Well, the problem is that an object which overrides\\n`finalize()` must now be determined to be garbage in at least two separate garbage collection cycles in order to be\\ncollected. When the first cycle determines that it is garbage, it becomes eligible for finalization. Because of the\\n(slim, but unfortunately real) possibility that the object was \\"resurrected\\" during finalization, the garbage collector\\nhas to run again before the object can actually be removed. And because finalization might not have happened in a timely\\nfashion, an arbitrary number of garbage collection cycles might have happened while the object was waiting for\\nfinalization. This can mean serious delays in actually cleaning up garbage objects, and is why you can get\\n`OutOfMemoryErrors` even when most of the heap is garbage.\\n\\nWith phantom reference, this situation is impossible -- when a `PhantomReference` is enqueued, there is absolutely no\\nway to get a pointer to the now-dead object (which is good, because it isn\'t in memory any longer). Because\\n`PhantomReference` cannot be used to resurrect an object, the object can be instantly cleaned up during the first\\ngarbage collection cycle in which it is found to be phantomly reachable. You can then dispose whatever resources you\\nneed to at your convenience.\\n\\nArguably, the `finalize()` method should never have been provided in the first place. phantom references are definitely\\nsafer and more efficient to use, and eliminating `finalize()` would have made parts of the VM considerably simpler. But,\\nthey\'re also more work to implement, so I confess to still using `finalize()` most of the time. The good news is that at\\nleast you have a choice."},{"id":"java-stream","metadata":{"permalink":"/jersey-webservice-template/blog/java-stream","editUrl":"https://github.com/QubitPi/jersey-webservice-template/tree/master/docs/blog/2021-04-30-java-stream.md","source":"@site/blog/2021-04-30-java-stream.md","title":"Java 8 Stream","description":"[//]: # (Copyright Jiaqi Liu)","date":"2021-04-30T00:00:00.000Z","formattedDate":"April 30, 2021","tags":[{"label":"Java","permalink":"/jersey-webservice-template/blog/tags/java"}],"readingTime":2.68,"hasTruncateMarker":true,"authors":[{"name":"Jack","title":"Maintainer of Jersey Webservice Template","url":"https://github.com/QubitPi","imageURL":"https://avatars.githubusercontent.com/u/16126939?v=4","key":"jiaqi"}],"frontMatter":{"slug":"java-stream","title":"Java 8 Stream","authors":"jiaqi","tags":["Java"]},"unlisted":false,"prevItem":{"title":"Understanding Weak References","permalink":"/jersey-webservice-template/blog/weak-references"},"nextItem":{"title":"What is Java EE","permalink":"/jersey-webservice-template/blog/java-ee"}},"content":"[//]: # (Copyright Jiaqi Liu)\\n\\n[//]: # (Licensed under the Apache License, Version 2.0 &#40;the \\"License\\"&#41;;)\\n[//]: # (you may not use this file except in compliance with the License.)\\n[//]: # (You may obtain a copy of the License at)\\n\\n[//]: # (    http://www.apache.org/licenses/LICENSE-2.0)\\n\\n[//]: # (Unless required by applicable law or agreed to in writing, software)\\n[//]: # (distributed under the License is distributed on an \\"AS IS\\" BASIS,)\\n[//]: # (WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.)\\n[//]: # (See the License for the specific language governing permissions and)\\n[//]: # (limitations under the License.)\\n\\n\x3c!--truncate--\x3e\\n\\nCombining a Collection of Predicates\\n------------------------------------\\n\\nWe chain a collection of Predicates by reducing them. In the following example, we have a list of predicates that we\\ncombined using `Predicate.and()`:\\n\\n```java\\n@Test\\npublic void whenFilterListWithCollectionOfPredicatesUsingAnd_thenSuccess(){\\n    List<Predicate<String>> allPredicates = new ArrayList<Predicate<String>>();\\n    allPredicates.add(str -> str.startsWith(\\"A\\"));\\n    allPredicates.add(str -> str.contains(\\"d\\"));\\n    allPredicates.add(str -> str.length() > 4);\\n\\n    List<String> result = names.stream()\\n        .filter(allPredicates.stream().reduce(x->true, Predicate::and))\\n        .collect(Collectors.toList());\\n\\n    assertEquals(1, result.size());\\n    assertThat(result, contains(\\"Alexander\\"));\\n}\\n```\\n\\nNote that we use our base identity as:\\n\\n```java\\nx->true\\n```\\n\\nThat will be, however, different if we want to combine them using Predicate.or():\\n\\n```java\\n@Test\\npublic void whenFilterListWithCollectionOfPredicatesUsingOr_thenSuccess(){\\n    List<String> result = names.stream()\\n        .filter(allPredicates.stream().reduce(x->false, Predicate::or))\\n        .collect(Collectors.toList());\\n\\n    assertEquals(2, result.size());\\n    assertThat(result, contains(\\"Adam\\",\\"Alexander\\"));\\n}\\n```\\n\\nCollecting Stream containing \\"null\\" to List\\n-------------------------------------------\\n\\n```java\\nperson.stream()\\n        .sorted(Comparator.comparingInt(Person::getDriverLicense))\\n        .collect(Collectors.toList());\\n```\\n\\nIf this stream contains a kid who doesn\'t know how to drive, the `Collectors.toList()` might see a `null` value, which\\ncauses `NullPointerException`, because `Collectors.toList()` gives us a list implementation that doesn\'t permit `null`\\nelements. `ArrayList`, however, permits `null` elements according to its JavaDoc. The solution them would be\\n\\n```java\\nperson.stream()\\n        .sorted(Comparator.comparingInt(Person::getDriverLicense))\\n        .collect(Collectors.toCollection(ArrayList::new));\\n```\\n\\nNote that the last line is changed so that the collect procedure returns an uer-specified list implementation, which is\\n`ArrayList`\\n\\nSorting\\n-------\\n\\n```java\\npublic class User {\\n\\n    private final String name;\\n    private final int age;\\n}\\n\\nfinal List<User> users = Arrays.asList(\\n        new User(\\"C\\", 30),\\n        new User(\\"D\\", 40),\\n        new User(\\"A\\", 10),\\n        new User(\\"B\\", 20),\\n        new User(\\"E\\", 50)\\n);\\n\\nList<User> sortedList = users.stream()\\n            .sorted(Comparator.comparingInt(User::getAge))\\n            .collect(Collectors.toList());\\n```\\n\\nRemove Duplicates from a List of Objects based on Property\\n----------------------------------------------------------\\n\\nYou can get a stream from the List and put in in the TreeSet from which you provide a custom comparator that compares\\nthe property uniquely. Then if you really need a list you can put then back this collection into an ArrayList:\\n\\n```java\\nimport static java.util.Comparator.comparingInt;\\nimport static java.util.stream.Collectors.collectingAndThen;\\nimport static java.util.stream.Collectors.toCollection;\\n\\n...\\nList<Employee> unique = employee.stream()\\n        .collect(\\n                collectingAndThen(\\n                        toCollection(() -> new TreeSet<>(comparingInt(Employee::getId))),\\n                        ArrayList::new\\n                )\\n        );\\n```\\n\\nGiven the example:\\n\\n```java\\nList<Employee> employee = Arrays.asList(new Employee(1, \\"John\\"), new Employee(1, \\"Bob\\"), new Employee(2, \\"Alice\\"));\\n```\\n\\nIt will output:\\n\\n```java\\n[Employee{id=1, name=\'John\'}, Employee{id=2, name=\'Alice\'}]\\n```\\n\\nConvert Iterable to Stream\\n--------------------------\\n\\n```java\\nStreamSupport.stream(iterable.spliterator(), false)\\n        .filter(...)\\n        .moreStreamOps(...);\\n```\\n\\nConvert Two Dimensional Array to List\\n-------------------------------------\\n\\n```java\\nList<Foo> collection = Arrays.stream(array)  //\'array\' is two-dimensional\\n        .flatMap(Arrays::stream)\\n        .collect(Collectors.toList());\\n```\\n\\nPreserve Order in Stream with collect\\n-------------------------------------\\n\\nSay we would like to process a list such as [\\"blah\\", \\"blah\\", \\"yep\\"] and get [\\"blah (2 times)\\", \\"yep\\"], we will collect\\nthem to a `LinkedHashMap` to get the expected result:\\n\\n```java\\nreturn messages.stream()\\n        .collect(groupingBy(Function.identity(), LinkedHashMap::new, summingInt(e -> 1)))\\n        .entrySet()\\n        .stream()\\n        .map(e -> e.getKey()+(e.getValue() == 1 ? \\"\\" : \\" (\\" + e.getValue() +\\" times)\\"))\\n        .collect(toList());\\n```"},{"id":"java-ee","metadata":{"permalink":"/jersey-webservice-template/blog/java-ee","editUrl":"https://github.com/QubitPi/jersey-webservice-template/tree/master/docs/blog/2020-10-26-java-ee/index.md","source":"@site/blog/2020-10-26-java-ee/index.md","title":"What is Java EE","description":"[//]: # (Copyright Jiaqi Liu)","date":"2020-10-26T00:00:00.000Z","formattedDate":"October 26, 2020","tags":[{"label":"Java","permalink":"/jersey-webservice-template/blog/tags/java"},{"label":"Standard","permalink":"/jersey-webservice-template/blog/tags/standard"}],"readingTime":5.645,"hasTruncateMarker":true,"authors":[{"name":"Jack","title":"Maintainer of Jersey Webservice Template","url":"https://github.com/QubitPi","imageURL":"https://avatars.githubusercontent.com/u/16126939?v=4","key":"jiaqi"}],"frontMatter":{"slug":"java-ee","title":"What is Java EE","authors":"jiaqi","tags":["Java","Standard"]},"unlisted":false,"prevItem":{"title":"Java 8 Stream","permalink":"/jersey-webservice-template/blog/java-stream"},"nextItem":{"title":"Refer to Environment Variables in POM","permalink":"/jersey-webservice-template/blog/env-var-in-pom"}},"content":"[//]: # (Copyright Jiaqi Liu)\\n\\n[//]: # (Licensed under the Apache License, Version 2.0 &#40;the \\"License\\"&#41;;)\\n[//]: # (you may not use this file except in compliance with the License.)\\n[//]: # (You may obtain a copy of the License at)\\n\\n[//]: # (    http://www.apache.org/licenses/LICENSE-2.0)\\n\\n[//]: # (Unless required by applicable law or agreed to in writing, software)\\n[//]: # (distributed under the License is distributed on an \\"AS IS\\" BASIS,)\\n[//]: # (WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.)\\n[//]: # (See the License for the specific language governing permissions and)\\n[//]: # (limitations under the License.)\\n\\n[Java EE](https://www.oracle.com/java/technologies/java-ee-glance.html) is a collection of specifications for developing\\nand deploying enterprise applications.\\n\\nIn general, enterprise applications refer to software hosted on servers that provide the applications that support the\\nenterprise.\\n\\nThe specifications (defined by Sun) describe services, application programming interfaces (APIs), and protocols.\\n\\nThe Java EE product provider is typically an application-server, web-server, or database-system vendor who provides\\nclasses that implement the interfaces defined in the specifications. These vendors compete on implementations of the\\nJava EE specifications.\\n\\nWhen a company requires Java EE experience what are they really asking for is experience using the technologies that\\nmake up Java EE. Frequently, a company will only be using a subset of the Java EE technologies.\\n\\nA reference implementation of Java EE is [GlassFish](https://javaee.github.io/glassfish/documentation)\\n\\n\x3c!--truncate--\x3e\\n\\nEvolution of Java EE\\n--------------------\\n\\nEver heard of Java EE? How about Java 2EE, J2EE, or now Jakarta EE? Actually, these are all different names for the same\\nthing: a set of enterprise specifications that extend Java SE. In this section, we discuss the evolution of Java EE.\\n\\n### History\\n\\nIn the first version of Java, Java enterprise extensions were simply\\n[a part of the core JDK](http://titanium.cs.berkeley.edu/doc/java-langspec-1.0/).\\n\\nThen, as part of Java 2 in 1999, these extensions were broken out of the standard binaries, and J2EE, or\\n[Java 2 Platform Enterprise Edition](https://www.oracle.com/java/technologies/appmodel.html), was born. It would keep\\nthat name until 2006.\\n\\nFor Java 5 in 2006, J2EE was renamed to Java EE or Java Platform Enterprise Edition. That name would stick all the way\\nto September 2017, when **something major happened**.\\n\\n**In September 2017,\\n[Oracle decided to give away the rights for Java EE to the Eclipse Foundation](https://www.redhat.com/en/blog/java-ee-moves-eclipse)\\n(the language is still owned by Oracle)**.\\n\\n![Error loading java-evolution.png](java-evolution.png)\\n\\n### In Transition\\n\\nActually, the Eclipse Foundation legally _had to_ rename Java EE. That\'s because Oracle has the rights over the \\"Java\\"\\nbrand.\\n\\nSo to choose the new name, the community voted and picked: **Jakarta EE**. In a certain way, it\'s still JEE.\\n\\nThis is still an evolving story, though, and the dust hasn\'t completely settled. For example, while Oracle open-sourced\\nthe source code, they did not open-source all the documentation. There\'s still a lot of discussion over this matter\\nbecause of legal issues that make it tricky to open-source documentation related to, for example, JMS and EJB.\\n\\nIt\'s not clear yet if new Eclipse Foundation documentation will be able to refer to the originals.\\n\\nAlso, curiously, the Eclipse Foundation can\'t create any new Java packages using the javax namespace, but it can create\\nnew classes and subclasses under the existing ones.\\n\\nThe transition also means [a new process for adding specifications](https://www.eclipse.org/projects/efsp/) to Jakarta\\nEE. To understand it better, let\'s take a look at what that process was like under Oracle and how it changes under the\\nEclipse Foundation in the next section.\\n\\n### The Future\\n\\nHistorically, in order for a feature to make it into \\"EE\\", we needed three things:\\n\\n1. a specification,\\n2. a reference implementation, and\\n3. tests\\n\\nThese three things could be provided by anyone in the community, and an Executive Committee would decide when these were\\nready to add to the language.\\n\\nTo better understand the past process, let\'s take a closer look at what JSRs(specification), Glassfish(implementation),\\nand the TCK(test) are and how they embodied new EE features.\\n\\n### The JCP -> EFSP\\n\\nIn the past, the process by which a new EE feature was born was called the Java Community Process\\n([JCP](https://jcp.org/en/home/index)).\\n\\nJava SE still uses the JCP today. But, since EE has changed its ownership, from Oracle to the Eclipse Foundation, we\\nhave a new and separate process for that. It\'s the Eclipse Foundation Specification Process\\n([EFSP](https://www.eclipse.org/projects/efsp/)) and it\'s an extension of the\\n[Eclipse Development Process](https://www.eclipse.org/projects/dev_process).\\n\\nThere are\\n[some important differences](https://blogs.eclipse.org/post/tanja-obradovic/how-eclipse-foundation-specification-process-efsp-different-java-community),\\nthough, mostly around \\"Transparency, Openness, Shared Burden and Vendor Neutrality\\"\\". The EFSP organizers, for example,\\nenvision collaborative working groups that are vendor-neutral, a certification process that is self-service, and an\\norganization that operates and governs as a meritocracy.\\n\\n### JSRs\\n\\nIn the JCP, the first step to adding a feature to EE was to create a JSR or Java Specification Request. The JSR was a\\nbit like the interface for an EE feature. The JCP Executive Committee reviewed and approved a completed JSR, and then\\nJSR contributors would code it up and make it available to the community.\\n\\nA good example of this was [JSR-339](https://jcp.org/en/jsr/detail?id=339)  - or JAX-RS - which was originally proposed\\nin 2011, approved by JCP in 2012 and finally released in 2013.\\n\\nAnd while the community could always weigh in while a specification was under discussion, time showed that an\\nimplementation-first approach \u2013 like in the case of [JSR 310](https://jcp.org/en/jsr/detail?id=310), `java.time`, and\\nJoda Time - tended to create more widely-accepted features and APIs.\\n\\nSo, the EFSP reflects this code-first view in its stated goal: \\"EFSP will be based on hands-on experimenting and coding\\nfirst, as a way to prove something is worthy of documenting in a specification\\".\\n\\n### Glassfish\\n\\nThen, as part of the JCP, a JSR needed a reference implementation. This is a bit like the class that implements the\\ninterface. A reference implementation helps developers of compatible libraries or other organizations that want to\\ncreate their own implementation of the spec.\\n\\nFor Java EE features, the JCP used Glassfish for its reference implementations.\\n\\nAnd while this centralization on Glassfish simplified the discovery process for implementers, that centralization also\\nrequired more governance and had a tendency to favor one vendor over another.\\n\\nHence, the EFSP doesn\'t require a reference implementation, but instead only a compatible implementation. Simply put,\\nthis subtle change makes so that **implementations inside of a central architecture, like Glassfish, won\'t be\\ninadvertently preferred by the foundation**.\\n\\n### TCK\\n\\nFinally, the JCP required that EE features be tested through the Technology Compatibility Kit, or\\n[TCK](https://projects.eclipse.org/projects/ee4j.jakartaee-tck).\\n\\nThe TCK was a suite of tests to validate a specific EE JSR. Simply put, in order to comply with Java EE, an application\\nserver needs to implement all of its JSRs and pass all the tests on the designated TCK.\\n\\nNot much changes here. Oracle open-sourced the TCK as well as the EE JSRs. Of course, all future documents and the TCK\\nwill be open-source."},{"id":"env-var-in-pom","metadata":{"permalink":"/jersey-webservice-template/blog/env-var-in-pom","editUrl":"https://github.com/QubitPi/jersey-webservice-template/tree/master/docs/blog/2019-08-23-env-var-in-pom.md","source":"@site/blog/2019-08-23-env-var-in-pom.md","title":"Refer to Environment Variables in POM","description":"[//]: # (Copyright Jiaqi Liu)","date":"2019-08-23T00:00:00.000Z","formattedDate":"August 23, 2019","tags":[{"label":"Java","permalink":"/jersey-webservice-template/blog/tags/java"},{"label":"Maven","permalink":"/jersey-webservice-template/blog/tags/maven"}],"readingTime":1.41,"hasTruncateMarker":true,"authors":[{"name":"Jack","title":"Maintainer of Jersey Webservice Template","url":"https://github.com/QubitPi","imageURL":"https://avatars.githubusercontent.com/u/16126939?v=4","key":"jiaqi"}],"frontMatter":{"slug":"env-var-in-pom","title":"Refer to Environment Variables in POM","authors":"jiaqi","tags":["Java","Maven"]},"unlisted":false,"prevItem":{"title":"What is Java EE","permalink":"/jersey-webservice-template/blog/java-ee"},"nextItem":{"title":"Java System Properties & Environment Variables API\'s","permalink":"/jersey-webservice-template/blog/java-env-properties"}},"content":"[//]: # (Copyright Jiaqi Liu)\\n\\n[//]: # (Licensed under the Apache License, Version 2.0 &#40;the \\"License\\"&#41;;)\\n[//]: # (you may not use this file except in compliance with the License.)\\n[//]: # (You may obtain a copy of the License at)\\n\\n[//]: # (    http://www.apache.org/licenses/LICENSE-2.0)\\n\\n[//]: # (Unless required by applicable law or agreed to in writing, software)\\n[//]: # (distributed under the License is distributed on an \\"AS IS\\" BASIS,)\\n[//]: # (WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.)\\n[//]: # (See the License for the specific language governing permissions and)\\n[//]: # (limitations under the License.)\\n\\n\x3c!--truncate--\x3e\\n\\nEnvironment Variables\\n---------------------\\n\\nTo refer to environment variables from the pom.xml, we can use the `${env.VARIABLE_NAME}` syntax.\\n\\nFor instance, let\'s use it to externalize the Java version in the build process:\\n\\n```xml\\n<build>\\n    <plugins>\\n        <plugin>\\n            <groupId>org.apache.maven.plugins</groupId>\\n            <artifactId>maven-compiler-plugin</artifactId>\\n            <version>3.8.1</version>\\n            <configuration>\\n                <source>${env.JAVA_VERSION}</source>\\n                <target>${env.JAVA_VERSION}</target>\\n            </configuration>\\n        </plugin>\\n    </plugins>\\n</build>\\n```\\n\\nWe should remember to pass the Java version information via environment variables. If we fail to do so, then we won\'t be\\nable to build the project.\\n\\nTo run the Maven goals or phases against such a build file, we should first export the environment variable. For\\ninstance\\n\\n```bash\\nexport JAVA_VERSION=17\\nmvn clean package\\n```\\n\\nIn order to provide a default when the `JAVA_VERSION` environment variable is missing we can use a Maven profile:\\n\\n```xml\\n<profiles>\\n    <profile>\\n        <id>default-java</id>\\n        <activation>\\n            <property>\\n                <name>!env.JAVA_VERSION</name>\\n            </property>\\n        </activation>\\n        <build>\\n            <plugins>\\n                <plugin>\\n                    <groupId>org.apache.maven.plugins</groupId>\\n                    <artifactId>maven-compiler-plugin</artifactId>\\n                    <version>3.8.1</version>\\n                    <configuration>\\n                        <source>1.8</source>\\n                        <target>1.8</target>\\n                    </configuration>\\n                </plugin>\\n            </plugins>\\n        </build>\\n    </profile>\\n</profiles>\\n```\\n\\nAs shown above, we\'re creating a profile and making it active only if the `JAVA_VERSION` environment variable is missing\\n(`!env.JAVA_VERSION` part). If that happens, then this new plugin definition will override the existing one."},{"id":"java-env-properties","metadata":{"permalink":"/jersey-webservice-template/blog/java-env-properties","editUrl":"https://github.com/QubitPi/jersey-webservice-template/tree/master/docs/blog/2019-08-07-java-env-properties.md","source":"@site/blog/2019-08-07-java-env-properties.md","title":"Java System Properties & Environment Variables API\'s","description":"[//]: # (Copyright Jiaqi Liu)","date":"2019-08-07T00:00:00.000Z","formattedDate":"August 7, 2019","tags":[{"label":"Java","permalink":"/jersey-webservice-template/blog/tags/java"}],"readingTime":2.135,"hasTruncateMarker":true,"authors":[{"name":"Jack","title":"Maintainer of Jersey Webservice Template","url":"https://github.com/QubitPi","imageURL":"https://avatars.githubusercontent.com/u/16126939?v=4","key":"jiaqi"}],"frontMatter":{"slug":"java-env-properties","title":"Java System Properties & Environment Variables API\'s","authors":"jiaqi","tags":["Java"]},"unlisted":false,"prevItem":{"title":"Refer to Environment Variables in POM","permalink":"/jersey-webservice-template/blog/env-var-in-pom"}},"content":"[//]: # (Copyright Jiaqi Liu)\\n\\n[//]: # (Licensed under the Apache License, Version 2.0 &#40;the \\"License\\"&#41;;)\\n[//]: # (you may not use this file except in compliance with the License.)\\n[//]: # (You may obtain a copy of the License at)\\n\\n[//]: # (    http://www.apache.org/licenses/LICENSE-2.0)\\n\\n[//]: # (Unless required by applicable law or agreed to in writing, software)\\n[//]: # (distributed under the License is distributed on an \\"AS IS\\" BASIS,)\\n[//]: # (WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.)\\n[//]: # (See the License for the specific language governing permissions and)\\n[//]: # (limitations under the License.)\\n\\n\x3c!--truncate--\x3e\\n\\nSystem Properties\\n-----------------\\n\\nThe Java platform uses a **Properties** object to provide information about the local system and configuration, and we\\ncall it **System Properties**.\\n\\nSystem Properties include information such as the current user, the current version of the Java runtime, and the file\\npath-name separator.\\n\\nIn the below code, we use `System.getProperty(\\"log_dir\\")` to read the value of the property `log_dir`. We also make use\\nof the default value parameter, so if the property doesn\'t exist, getProperty returns `/tmp/log`:\\n\\n```java\\nString log_dir = System.getProperty(\\"log_dir\\",\\"/tmp/log\\");\\n```\\n\\nTo update System Properties at runtime, we use the **System.setProperty** method:\\n\\n```java\\nSystem.setProperty(\\"log_dir\\", \\"/tmp/log\\");\\n```\\n\\nWe can pass our own properties or configurations values to the application using the **propertyName** command line\\nargument:\\n\\n```java\\njava -jar jarName -DpropertyName=value\\n```\\n\\nFor example\\n\\n```java\\njava -jar app -Dfoo=\\"bar\\"\\n```\\n\\nEnvironment Variables\\n---------------------\\n\\nEnvironment Variables are key/value pairs like Properties. Many Operating Systems use Environment Variables to allow\\n_configuration information to be passed into applications_.\\n\\nThe way to set an environment variable differs from one operating system to another. For example, on Linux, we use\\n\\n```bash\\nexport MY_ENV_VAR=foo\\n```\\n\\n_When creating a process, it inherits a clone environment of its parent process by default_.\\n\\nTo obtain a single environment variable programmatically, we can call **getenv** with the variable name:\\n\\n```java\\nString log_dir = System.getenv(\\"log_dir\\");\\n```\\n\\n:::caution\\n\\ngetenv() returns a _read-only_ Map. Trying to add values to the map throws an UnsupportedOperationException.\\n\\n:::\\n\\nThe Differences\\n---------------\\n\\nAlthough both are essentially maps that provide String values for String keys, let\'s look at a few differences:\\n\\n1. We can update Properties at runtime, while Environment Variables are an immutable copy of the Operating System\'s\\n   variables.\\n2. Properties are contained only within the Java platform, while Environment Variables are global at the Operating\\n   System level, available to all applications running on the same machine.\\n3. Properties must exist when packaging the application, but we can create Environment Variables on the Operating\\n   System at almost any point."}]}')}}]);